import App.Executive
import Util.Object
import IO.InputStream
import IO.Serializer
import IO.OutputStream
import sys
import os
import string


class AMF:
    
    executive = None
    debug = 0
    encoding = None
    debugDir = None
    
    def __init__(self):
        self.executive = App.Executive.Executive()
        self.debug = 0
    
    def service(self):
        if os.environ.has_key('CONTENT_LENGTH'):
            content = sys.stdin.read()
            #read the whole STDIN into one variable    
            self._service(content)
    
    def fromFile(self,file):
        if not file:
            file = self.debugDir+"input.amf" 
    
        # temporary load the contents from a file
        content = self._loadRawDataFromFile(file)
    
        # build the input stream object from the file contents
        inputStream = IO.InputStream.InputStream(content)
        
        # build the deserializer and pass it a reference to the inputstream
        deserializer = IO.Deserializer.Deserializer(inputStream, self.encoding)
        
        # get the returned Object
        amfin = deserializer.getObject()
    
        return amfin
    
    def _service(self, content) :
        
        if self.debug :
            # WATCH OUT, THIS IS NOT THREAD SAFE, DON'T USE IN CONCURRENT ENVIRONMENT
            # temporary load the contents from a file
            content = self._loadRawDataFromFile(self.debugDir+"/input.amf")
        
            # save the raw amf data to a file
            #self._saveRawDataToFile (self.debugDir."/input.amf", content)
        
        # build the input stream object from the file contents
        inputStream = IO.InputStream.InputStream(content)
        
        # build the deserializer and pass it a reference to the inputstream
        deserializer = IO.Deserializer.Deserializer(inputStream, self.encoding)
        
        # get the returned Object
        amfin = deserializer.getObject()
        
        # we can add much functionality with the headers here, like turn on server debugging, etc.
        headercount = amfin.numHeader()
        
        for i in range(headercount):
            header = amfin.getHeaderAt(i)
#            if (header.'key'} eq "DescribeService")
#            {
#                self.exec}.setHeaderFilter("DescribeService")
#            }
            # other headers like net debug config
            # and Credentials
    
        
        # get the number of body elements
        bodycount = amfin.numBody()
        
        # create Object for storing the output
        amfout = Util.Object.Object()
        
        # loop over all of the body elements
        for i in range(bodycount):
            body = amfin.getBodyAt(i)
            # set the packagePath of the executive to be our method's uri
            #Simon - unused for now
            self.executive.setTarget( body.target )
            #/Simon
            # execute the method and pass it the arguments
            results = self.executive.doMethodCall( body.value)
            # get the return type
            #sys.stderr.write(cPickle.dumps(results))
            returnType = self.executive.getReturnType()
            # save the result in our amfout object
            amfout.addBody(body.response+"/onResult", "null", results, returnType)
        
        # create a new output stream
        outstream = IO.OutputStream.OutputStream()
    
        # create a new serializer
        serializer = IO.Serializer.Serializer (outstream, self.encoding)
        
        # serialize the data
        serializer.serialize(amfout)
    
        if 0 :
            # save the raw data to a file for debugging
            self._saveRawDataToFile (self.debugDir+"/results.amf", outstream.flush())
    
        # send the correct header
        response = outstream.flush()
    
        self.output(response)
    
        return self
    
    def output(self, response):
    
        resLength = len(response)
    
        sys.stdout.write ("Content-Type: application/x-amf\n")
        sys.stdout.write ("Content-Length: " + str(resLength) + "\n")
        sys.stdout.write("\n")
    
        # flush the amf data to the client.
        sys.stdout.write(response)
    
    
    def setBaseClassPath(self, path):
        if os.path.exists(path):
            self.executive.setBaseClassPath(path)
        else:
            sys.stderr.write("Directory path does not exist and could not be registered.\n")
            exit

    def setRelativeBaseClassPath(self, path):
		child = os.popen("pwd")
		pwd = child.read()
		pwd = string.rstrip(pwd)
		path = pwd + path;
		self.setBaseClassPath(path)

    
    def registerService(self, package, servicepackage):
        self.executive.registerService(package, servicepackage)
    
    
    #    useful debugging method 
    #    You can save the raw  data sent from the
    #    flash client by calling
    #    self._saveRawDataToFile("file.amf",  contents)
    
    def _saveRawDataToFile(self, filepath, data):
        # open the file for writing
        file = open ("filepath")
        if not file:
            sys.stderr.write("Could not open file filepath: !\n")
            exit
        # write to the file
        f.write(data)
        f.close()
    
    def _appendRawDataToFile(self, filepath, data):
        # open the file for writing
        file = open ("filepath", "a")
        if not file:
            sys.stderr.write("Could not open file filepath: !\n")
            exit
        # write to the file
        f.write(data)
        f.close()
    
    
    # get contents of a file into a string
    def _loadRawDataFromFile(self, filepath):
        # open a handle to the file
        file = open(filepath)
        # read the entire file contents
        contents = file.read
        # close the file handle
        file.close 
        # return the contents
        return contents
    
    def log(self, content):
        self._appendRawDataToFile (self.debugDir+"processing.txt"+content+"\n")
    
