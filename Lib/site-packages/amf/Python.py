class Python:
    
    __slots__ = ['executive', 'debug', 'encoding', 'debugDir']

    def __init__(self):
        self.executive = Executive()
        self.debug = 0
    
    def service(self):
    
        content = os.read(stdin, environ['CONTENT_LENGTH'])
        #read the whole STDIN into one variable
    
        self._service(content)
    
    def fromFile(self,file):
        if not file:
            file = self.debugDir+"input.amf" 
    
        # temporary load the contents from a file
        content = self._loadRawDataFromFile(file)
    
        # build the input stream object from the file contents
        inputStream = InputStream(content)
        
        # build the deserializer and pass it a reference to the inputstream
        deserializer = Deserializer(inputStream, self.encoding)
        
        # get the returned Object
        amfin = deserializer.getObject()
    
        return amfin
    
    def _service(self, content) :
        
        if self.debug :
            # WATCH OUT, THIS IS NOT THREAD SAFE, DON'T USE IN CONCURRENT ENVIRONMENT
            # temporary load the contents from a file
            content = self._loadRawDataFromFile(self.debugDir+"/input.amf")
        
            # save the raw amf data to a file
            #self._saveRawDataToFile (self.debugDir."/input.amf", content)
        
        # build the input stream object from the file contents
        inputStream = InputStream(content)
        
        # build the deserializer and pass it a reference to the inputstream
        deserializer = Deserializer(inputStream, self.encoding)
        
        # get the returned Object
        amfin = deserializer.getObject()
        
        # we can add much functionality with the headers here, like turn on server debugging, etc.
        headercount = amfin.numHeader()
        
        for i in range(headercount):
            header = amfin.getHeaderAt(i)
#            if (header.'key'} eq "DescribeService")
#            {
#                self.exec}.setHeaderFilter("DescribeService")
#            }
            # other headers like net debug config
            # and Credentials
    
        
        # get the number of body elements
        bodycount = amfin.numBody()
        
        # create Object for storing the output
        amfout = Object()
        
        # loop over all of the body elements
        for i in range(bodycount):
            body = amfin.getBodyAt(i)
            # set the packagePath of the executive to be our method's uri
            #Simon - unused for now
            self.executive.setTarget( body.target )
            #/Simon
            # execute the method and pass it the arguments
            results = self.executive.doMethodCall( body.value)
            # get the return type
            returnType = self.executive.getReturnType()
            # save the result in our amfout object
            amfout.addBody(body.response+"/onResult", "null", results, returnType)
        
        # create a new output stream
        outstream = OutputStream ()
    
        # create a new serializer
        serializer = Serializer (outstream, self.encoding)
        
        # serialize the data
        serializer.serialize(amfout)
    
        if 0 :
            # save the raw data to a file for debugging
            self._saveRawDataToFile (self.debugDir+"/results.amf", outstream.flush())
    
        # send the correct header
        response = outstream.flush()
    
        self.output(response)
    
        return self
    
    def output(self, response):
    
        resLength = len(response)
    
        sys.stdout.write ("""
    Content-Type: application/x-amf
    Content-Length: resLength
    
""")
    
        # flush the amf data to the client.
        sys.stdout.write(response)
    
    
    def setBaseClassPath(self, path):
        if os.path.exists(path):
            self.executive.setBaseClassPath(path)
        else:
            sys.stderr.write("Directory path does not exist and could not be registered.\n")
            exit
    
    def registerService(self, package, servicepackage):
        self.executive.registerService(package, servicepackage)
    
    
    #    usefulldebugging method 
    #    You can save the raw  data sent from the
    #    flash client by calling
    #    self._saveRawDataToFile("file.amf",  contents)
    
    def _saveRawDataToFile(self, filepath, data):
        # open the file for writing
        file = open ("filepath")
        if not file:
            sys.stderr.write("Could not open file filepath: !\n")
            exit
        # write to the file
        f.write(data)
        f.close()
    
    def _appendRawDataToFile(self, filepath, data):
        # open the file for writing
        file = open ("filepath", "a")
        if not file:
            sys.stderr.write("Could not open file filepath: !\n")
            exit
        # write to the file
        f.write(data)
        f.close()
    
    
    # get contents of a file into a string
    def _loadRawDataFromFile(self, filepath):
        # open a handle to the file
        file = open(filepath)
        # read the entire file contents
        contents = file.read
        # close the file handle
        file.close 
        # return the contents
        return contents
    
    def log(self, content):
        self._appendRawDataToFile (self.debugDir+"processing.txt"+content+"\n")
    
