import string
import struct
import array
import sys

class InputStream:
    
    current_byte = 0
    raw_data = []
    content_length = 0
    little_endian = 0

    #InputStream constructor
    #arguments	rd	raw data stream
    def __init__(self, rd):
        self.current_byte=0
        # store the stream in this object
        self.raw_data =  list(rd)
        # grab the total length of this stream
        self.content_length = len(self.raw_data)

	#Determine endianness
	if ord(array.array("i",[1]).tostring()[0]) == 1:
		self.little_endian = 1
	else:
		self.little_endian = 0
    
    
    # returns a single byte value.
    def readByte(self):
        # boundary check
        if self.current_byte > self.content_length - 1:
            sys.stderr.write("Malformed AMF data, cannot readByte\n")
            exit	

        # return the next byte
        nextByte = self.raw_data[self.current_byte]
        if nextByte:
            result = ord(nextByte) 
        self.current_byte += 1
        return result
    
    # returns the value of 2 bytes
    def readInt(self):
        # boundary check
        if self.current_byte > self.content_length - 2:
            sys.stderr.write("Malformed AMF data, cannot readInt\n")
            exit

        # read the next 2 bytes, shift and add

        thisByte = self.raw_data[self.current_byte]
        nextByte = self.raw_data[self.current_byte+1]
    
        thisByte = 0
        thisNum = 0
        if thisByte:
            thisNum = ord(thisByte) 
        nextNum = 0
        if nextByte:
            nextNum = ord(nextByte)
    
        result = ((thisNum) << 8) | nextNum
    
        self.current_byte += 2
        return result
    
    # returns the value of 4 bytes
    def readLong(self):
       # boundary check
        if self.current_byte > self.content_length - 4:
            sys.stderr.write("Malformed AMF data, cannot readLong\n")
            exit

        byte1 = self.current_byte
        byte2 = self.current_byte+1
        byte3 = self.current_byte+2
        byte4 = self.current_byte+3
        # read the next 4 bytes, shift and add
        result = ((ord(self.raw_data[byte1]) << 24) | 
                        (ord(self.raw_data[byte2]) << 16) |
                        (ord(self.raw_data[byte3]) << 8) |
                            ord(self.raw_data[byte4]))
        self.current_byte += 4
        return result
    
    # returns the value of 8 bytes
    def readDouble(self):
        # boundary check
        if self.current_byte > self.content_length - 8:
            sys.stderr.write("Malformed AMF data, cannot readDouble\n")
            exit

        # container to store the reversed bytes
        invertedBytes = ""
        if self.little_endian == 1:
            # create a loop with a backwards index
            for i in range (7, -1, -1):
            # grab the bytes in reverse order from the backwards index
                nextByte = self.raw_data[self.current_byte+i]
                if nextByte:
                        invertedBytes += nextByte 
        else:
            for i in range (0, 8, 1):
                nextByte = self.raw_data[self.current_byte+i]
                if nextByte:
                        invertedBytes += nextByte 
        
        # move the seek head forward 8 bytes
        self.current_byte += 8
        # unpack the bytes
        zz = struct.unpack("1d", invertedBytes)
        # return the number from the associative array
        return zz[0]
    
    
    # returns a UTF string
    def readUTF(self):
        # get the length of the string (1st 2 bytes)
        length = self.readInt()
        # boundary check
        if self.current_byte > self.content_length - length:
            sys.stderr.write("Malformed AMF data, cannot readUTF\n")
            exit

        # grab the string
        slice = self.raw_data[self.current_byte : self.current_byte+length]
        val = string.join (slice, "")
        # move the seek head to the end of the string
        self.current_byte += length
        # return the string
        return val
    
    # returns a UTF string with a LONG representing the length
    def readLongUTF(self):
        # get the length of the string (1st 4 bytes)
        length = self.readLong()
        # boundary check
        if self.current_byte > self.content_length - length:
            sys.stderr.write("Malformed AMF data, cannot readLongUTF\n")
            exit

        # grab the string
        slice = self.raw_data[self.current_byte : self.current_byte+length]
        val = string.join (slice, "")
        # move the seek head to the end of the string
        self.current_byte += length
        # return the string
        return val
