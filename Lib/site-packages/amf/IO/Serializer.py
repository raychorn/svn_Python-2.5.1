import types
import sys

class Serializer:
    
    __slots__ = ['out', 'encoding', 'amfout', 'target', '__columnTypes__']

    def __init__(self, stream, encoding):
        self.out = stream
        self.encoding = encoding
        

    def serialize(self, d):
        self.amfout = d
        # write the version ???
        self.out.writeInt(0)
        
        # get the header count
        count = self.amfout.numHeader()
        # write header count
        self.out.writeInt(count)
        
        for i in range(count):
            self.writeHeader(i)
            
        count = self.amfout.numBody()
        # write the body count
        self.out.writeInt(count)
        
        for i in range(count):
            # start writing the body
            self.writeBody(i)
    
    def writeHeader(self, i):
        # for all header values
        # write the header to the output stream
        # ignoring header for now
        return 1
    
    def writeBody(self, i):
        body = self.amfout.getBodyAt(i)
        # write the responseURI header
        self.out.writeUTF(body.target)
        # write null, haven't found another use for this
        self.out.writeUTF(body.response)
        # always, always there is four bytes of FF, which is -1 of course
        self.out.writeLong(-1)
        # write the data to the output stream
        self.writeData(body.value, body.type)
    
    # writes a boolean
    def writeBoolean(self, d):
        # write the boolean flag
        self.out.writeByte(chr(1))
        # write the boolean byte
        if d==True:
        	self.out.writeByte(chr(1))
        else:
        	self.out.writeByte(chr(0))

    # writes a string under 65536 chars, a longUTF is used and isn't complete yet
    def writeString(self, d):
        # write the string code
        self.out.writeByte(chr(2))
        # write the string value
        self.out.writeUTF(d)
    
    def writeXML(self, d):
        self.out.writeByte(chr(15))
        #self.out.writeLongUTF(utf8_encode(d))
        self.out.writeLongUTF(d)
    
    # must be used PHPRemoting with the service to set the return type to date
    # still needs a more in depth look at the timezone
    def writeDate(self, d):
        # write date code
        self.out.writeByte(chr(11))
        # write date (milliseconds from 1970)
        self.out.writeDouble(d)
        # write timezone
        # ?? this is wierd -- put what you like and it pumps it back into flash at the current GMT ?? 
        # have a look at the amf it creates...
        self.out.writeInt(0) 
    
    # write a number formatted as a double with the bytes reversed
    # this may not work on a Win machine because i believe doubles are
    # already reversed, to fix this comment out the reversing part
    # of the writeDouble method
    def writeNumber(self, d):
        # write the number code
        self.out.writeByte(chr(0))
        # write the number as a double
        self.out.writeDouble(d)

    # write null
    def writeNull(self):
        # null is only a 0x05 flag
        self.out.writeByte(chr(5))
    
    # write array
    # since everything in php is an array this includes arrays with numeric and string indexes
    def writeArray(self, d):
    
        length = len(d)
        # write the numeric array code
        self.out.writeByte(chr(10))
        # write the count of items in the array
        self.out.writeLong(length)
        # write all of the array elements
        for i in range(length):
            self.writeData(d[i], None)
        
    def writeHash(self, d):
        # this is an object so write the object code
        self.out.writeByte(chr(3))
        # write the object name/value pairs	
        self.writeObject(d)

    # writes an object to the stream
    def writeObject(self, d):
        # loop over each element
        
        #attribs = NONE
        if type(d) is types.InstanceType:
            attribs = dir(d)
        else:
            attribs = d.keys()

        #for key in attribs:
        #    data = self.__getattribute__(key)
        for key in attribs:
            data = None
            if type(d) is types.InstanceType:
                data = getattr(d,key)
                #Discard any method names.
                if callable(data): continue
            else:
            	data = d[key]
            
            # write the name of the object
            self.out.writeUTF(key)
            # write the value of the object
            self.writeData(data, None)
        # write the end object flag 0x00, 0x00, 0x09
        self.out.writeInt(0)
        self.out.writeByte(chr(9))    
    
    # write an AMF object
    # The difference with regular object is that the code is different
    # and the class name is explicitly sent. Good for RecordSets.
    def writeAMFObject(self, object):
        # write the custom package code
        self.out.writeByte(chr(16))
        # write the package name
        self.out.writeUTF(object._explicitType);
        if hasattr(object, "__columnTypes__"):
            self.__columnTypes__ = object.__columnTypes__
        # write the package's data
        self.writeObject(object)
        self.__columnTypes__ = None
    
    # main switch for dynamically determining the data type
    
    def writeData(self, d, dataType):
        
        if dataType == None:
            dataType = "unknown" 
    
    #    **************** TO DO **********************
    #    Since we are now allowing the user to determine
    #    the datatype we have to validate the user's suggestion
    #    vs. the actual data being passed and throw an error
    #    if things don't check out.!!!!
    #    **********************************************

	version_info = sys.version_info

        # get the type of the data by checking its reference name
        #if it was not explicitly passed
        if dataType == "unknown":
            if type(d) is types.NoneType:
                dataType = "NULL"
            elif type(d) is types.IntType or type(d) is types.LongType or type(d) is types.FloatType:
                dataType = "double"
            elif type(d) is types.StringType or type(d) is types.UnicodeType:
                dataType = "string"
            elif version_info[0]>=2 and version_info[1]>=3 and type(d) is types.BooleanType:
               	dataType = "boolean"
            elif type(d) is types.ListType:
                dataType = "array"
            elif type(d) is types.TupleType:
                dataType = "array"
            elif type(d) is types.DictType:
                dataType = "hash"
            elif type(d) is types.InstanceType:
                dataType = "object"
            else:
                dataType = str(type(d))
        
        dataType = dataType.lower()
        #sys.stderr.write("Data type " + str(type(d)) + " of value " + str(d)+"\n")
        
        #BOOLEANS
        if dataType == "boolean":
            self.writeBoolean(d)
        #STRINGS
        elif dataType == "string":
            self.writeString(d)
        # DOUBLES
        elif dataType == "double":
            self.writeNumber(d)
        # INTEGERS
        elif dataType == "integer":
            self.writeNumber(d)
        # OBJECTS
        elif dataType == "object":
            self.writeHash(d)
        # ARRAYS
        elif dataType == "array":
            self.writeArray(d)
        # HASHES
        elif dataType == "hash":
            self.writeHash(d)
        # NULL
        elif dataType == "null":
            self.writeNull()
        # XML
        elif dataType == "xml":
            self.writeXML(d)
        # Dates
        elif dataType == "date":
            self.writeDate(d)
        # mysql recordset resource
        elif dataType == "amfobject":
            # write the record set to the output stream
            self.writeAMFObject(d) # writes recordset formatted for Flash
        else:
            sys.stderr.write("Unsupported datatype " + str(dataType) + " in AMF.Python.IO.Serializer"+"\n")
            sys.stderr.write("while processing object " + str(d) + "\n")
            sys.exit
        
