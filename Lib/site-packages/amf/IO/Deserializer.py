import math
import sys
import AMF.Util.Object

class Deserializer:

    amfdata = None
    inputStream = None
    encoding = None

    def __init__(self, stream, encoding):
        self.amfdata= AMF.Util.Object.Object()
        self.inputStream = stream
        self.encoding = encoding
        self.readHeader()
        self.readBody()
            
    # returns the instance of the Object package
    def getObject(self):
        return self.amfdata
    
    #******************** PRIVATE METHODS ****************************/
    
    def readHeader(self):
        # ignore the first two bytes -- version or something
        self.inputStream.readInt()
        # find the total number of header elements
        header_count = self.inputStream.readInt()
        # loop over all of the header elements
        while header_count:
            header_count = header_count - 1
            name = self.inputStream.readUTF()
            # find the must understand flag
            required = self.readBoolean()
            # grab the length of the header element
            length = self.inputStream.readLong()
            # grab the type of the element
            type = self.inputStream.readByte()
            # turn the element into real data
            content = self.readData(type)
            # save the name/value into the headers array
            self.amfdata.addHeader(name, required, content)
    
    def readBody(self):
        # find the total number of body elements
        body_count = self.inputStream.readInt()
        
        # loop over all of the body elements
        while body_count:
            body_count = body_count - 1
            method = self.readString()
            # the target that the client understands
            target = self.readString()
            # grab the length of the body element
            length = self.inputStream.readLong()
            
            # grab the type of the element
            type = self.inputStream.readByte()

            # turn the argument elements into real data
            data = self.readData(type)
            # add the body element to the body object
            self.amfdata.addBody(method, target, data, "")
    
    
    # reads an object and converts the binary data into a Python object
    def readObject(self):
        ret = AMF.Util.Object.Object()
        
        # grab the key
        key = self.inputStream.readUTF()            
        type = self.inputStream.readByte()
        while type != 9:
            if not type:
                sys.stderr.write("Malformed AMF data, no object end byte!\n")
                exit
            # grab the value
            val = self.readData(type)
            # save the name/value pair in the array
            setattr(ret, key, val)
            
            # get the next name
            key = self.inputStream.readUTF()
            type = self.inputStream.readByte()            
        # return the array
        return ret
    
    # reads and array object and converts the binary data into a Perl array
    def readArray(self):
        # init the array object
        ret = []
        # get the length of the array
        length = self.inputStream.readLong()
        if length > self.inputStream.content_length:
            sys.stderr.write("Malformed AMF data,  array length too big!\n")
            exit

        # loop over all of the elements in the data
        for i in range (length):
            # grab the type for each element
            type = self.inputStream.readByte()
            # grab each element
            ret.append(self.readData(type))
        # return the data
        return ret    
    
    def readCustomClass(self):
        # grab the explicit type -- I'm not really convinced on this one but it works,
        # the only example i've seen is the NetDebugConfig object
        typeIdentifier = self.inputStream.readUTF()
        # the rest of the bytes are an object without the 0x03 header
        value = self.readObject()
        # save that type because we may need it if we can find a way to add debugging features
        setattr(value,'explicitType', typeIdentifier)
        # return the object
        return value        
    
    def readNumber(self):
        # grab the binary representation of the number
        return self.inputStream.readDouble()	
    
    # read the next byte and return its boolean value
    def readBoolean(self):
        # grab the int value of the next byte
        int = self.inputStream.readByte()
        # if it's a 0x01 return true else return false
        return (int == 1)
    
    def readString(self):
        s = self.inputStream.readUTF()
        return s
    
    #No dates in python - return a string
    def readDate(self):
        ms = self.inputStream.readDouble() # date in milliseconds from 01/01/1970
    
        # nasty way to get timezone 
        int = self.inputStream.readInt()
        if int > 720:
            int = -(65536 - int)
        hr = math.floor(int / 60)
        min = int % 60
        timezone = "GMT " + str(hr) + ":" + str(abs(min))
        # end nastiness 
    
        # is there a nice way to return entire date(milliseconds and timezone) in PHP???
        return ms 
    
    # XML comes in as a plain string except it has a long displaying the length instead of a short?
    def readXML(self):
            # reads XML
        rawXML = self.inputStream.readLongUTF()
        
        # return the xml
        return rawXML

    def readFlushedSO(self):
        # receives [type(07) 00 00] if SO is flushed and contains 'public' properties
        # see debugger readout ???
        return self.inputStream.readInt()
    
    def readASObject(self):
        #object Button, object Textformat, object Sound, object Number, object Boolean, object String, 
        #SharedObject unflushed, XMLNode, used XMLSocket??, NetConnection,
        #SharedObject.data, SharedObject containing 'private' properties
    
        #the final byte seems to be the dataType . 0D
        return None
    
    # main switch function to process all of the data types
    def readData(self, type):
        if type == 0: # number
            data = self.readNumber()
        elif type == 1: # boolean
            data = self.readBoolean()
        elif type == 2: # string
            data = self.readString()
        elif type == 3: # object Object
            data = self.readObject()
        elif type == 5: # null
            data = None
        elif type == 6: # Noneined
            data = None
        elif type == 7: # flushed SharedObject containing 'public' properties
            data = self.readFlushedSO() 
        elif type == 8: # array
        
            # shared object format only (*.sol) 
            # only time I saw it was the serverinfo value in a ColdFusion RecordSet
            # It was just four zeroes - skip them.
            for i in range(4):
                self.inputStream.readByte()
            
        elif type == 10: # array
            data = self.readArray()
        elif type == 11: # date
            data = self.readDate()
        elif type == 13: # mainly internal AS objects
            data = self.readASObject()
        elif type == 15: # XML
            data = self.readXML()
        elif type == 16: # Custom Class
            data = self.readCustomClass()
        else: # unknown case
            sys.stderr.write("Unknown type of incoming data")
        return data
