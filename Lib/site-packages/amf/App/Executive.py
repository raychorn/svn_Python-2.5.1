import sys

class Executive:

    services = {}
    target = None
    _basecp = None
    _headerFilter = None
    _instanceName = None
    _methodName = None
    _className = None
    _returnType = None
        
    # setter for the _headerFilter
    def setHeaderFilter(self,header):
        self._headerFilter= header
    
    # Set the base classpath. This is the path from which will be search for the packagees and functions
    # basecp should end with a "/"
    def setBaseClassPath(self,basecp):
        self._basecp= basecp 
    
    def setInstanceName(self,name):
        self._instanceName= name
    
    # you pass directory.script.method to this and it will build
    # the classpath, classname and methodname values
    def setTarget(self,target):
        self.target= target
        # grab the position of the last . char
        lpos = target.rfind(".")
        # there were none
        if not lpos:
            sys.stderr.write ("Service name target does not contain a dot.\n")
            # throw an error because there has to be atleast 1
        else:
            # the method name is the very last part
            self._methodname= target[lpos+1:]

        # truncate the method name from the string
        trunced = target[0:lpos]
        
        self._classname= trunced
    
    
    def registerService(self,package, servicepackage):
        self.services[package] = servicepackage
    
    # returns the return type for this method
    def getReturnType(self):
        return self._returnType
    
    # execute the method using dynamic inclusion of Perl files
    def doMethodCall(self,a):
        
        #First try to call a registered class...
        package = self._classname
        method = self._methodname
        
        calledMethod = method
        import cPickle
        
        if self.services.has_key(package):
            return self.doMethodCall_registered(package, method, a)
        
        #Otherwise, browse in the directory specified by the user.
    
        sys.path.append(self._basecp)
    
        # build the class object
        
        #TODO - handle exception
        exec "import " + package
#        {
            # report back to flash that the class wasn't properly formatted
#            print STDERR  "Class package does not exist or could not be loaded.\n"
#        print STDERR @
#            return
#        }
    
        # build the construct from the extended class
        #TODO - only use last part before ()
        exec "object = " + package+"."+package+"()"

        self._classConstruct= object
    
        methodTable = self._classConstruct.methodTable()
    # was this defined in the methodTable -- required to enable AMF::Perl service approach
        if methodTable.has_key(method):
    # create a shortcut to the methodTable
            methodrecord = methodTable[method]
    
    # check to see if this method name is aliased
            if methodrecord.has_key('alias'):
    # map the _methodname to the alias
                method = methodrecord['alias']
    
            # check to see if an explicit return type was defined
            if methodrecord.has_key('returns'):
                self._returnType = methodrecord['returns']
            # set the default return type of "unknown"
            else:
                self._returnType= "unknown";
                
            # set to see if the access was set and the method as remote permissions.
            if methodrecord.has_key('access') and methodrecord['access'].lower() == "remote":
                # finally check to see if the method existed
                if hasattr(self._classConstruct, method):
                    # execute the method and return it's results to the gateway
                    func = getattr(self._classConstruct, method)
                    result = func(*a)
                    return result
                else:
                    sys.stderr.write ("Method " + calledMethod + " does not exist in class "+self._classConstruct+".\n")
            else:
                sys.stderr.write ("Access Denied to " + calledMethod + "\n")
        else:
            sys.stderr.write ("Function " + calledMethod + " does not exist in class " + self._classConstruct+".\n")
    
    
    
    def doMethodCall_registered(self,package, method, a):
        
        serviceobject = self.services[package]

        if len(package) == 0:
        # TODO: handle non packaged functions
        #trigger_error("ERROR: no package in call",E_USER_ERROR)
            return
        elif not serviceobject:
            sys.stderr.write ("Package "+package+" not registerd on server\n")
            return
        elif not hasattr(serviceobject, method):
            sys.stderr.write ("Function "+method+" does not exist in package "+package+"\n")
            return
        else:
            self._returnType= "unknown"
    
            if hasattr(serviceobject, "methodTable") and hasattr (serviceobject.methodTable, method):
                
                # create a shortcut to the methodTable
                methodrecord = serviceobject.methodTable[method]
                # check to see if an explicit return type was defined
                if hasattr(methodrecord, 'returns'):
                    self._returnType= methodrecord['returns']
                # set the default return type of "unknown"
                else:
                    self._returnType= "unknown"
            func = getattr(serviceobject, method)
            result = func(*a)
            return result
    


