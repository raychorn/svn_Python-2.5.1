from swocket import *

class swocket_daemon (asyncore.dispatcher):
  """listens for connections"""
  def __init__ (self, config):
    asyncore.dispatcher.__init__ (self)
    self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
    self.set_reuse_addr()
    self.config = config
    self.bind((self.config.host, self.config.port))
    self.logclass = self.config.logclass
    self.logerror("[%s] listening started"%self.config.name)
    self.listen (5)
    self.count = 0
    self.connections = {}

  def __repr__ (self):
    return '<swocket_daemon at %X %s>'%(id(self),str(self))

  def __str__(self):
    return 'host=%s port=%s'%(`self.config.host`,`self.config.port`)

  def log (self,text):
    self.logclass.log(text)

  def logerror (self,text):
    self.logclass.logerror(text)

  def logdebug (self,text):
    self.logclass.logdebug(text)
    
  def handle_accept (self):
    self.count += 1
    try:    swocket_server (self, self.count, self.accept())
    except: self.logerror("accept() error on connection %d"%self.count)

  def destroy (self):
    self.config.destroy()
    self.config = None
    self.logerror("[%s] shutdown")
    asyncore.socket_map.clear()
    raise asyncore.ExitNow

class swocket_server (asynchat.async_chat):
  """this is what does the server<=>client stuff"""
  def __init__ (self, daemon, count, (conn, addr)):
    asynchat.async_chat.__init__(self, conn)
    self.set_terminator ('\0')
    self.daemon = daemon
    self.buffer = ''
    self.id = id(self)
    self.ip = addr[0]
    self.count = count
    self.module = initModule(self)
    # initialized on connect
    self.service = None
    self.vhost = None
    self.vhostName = ''
    self.fullpath = ''
    self.path = ''
    self.extrapath = None
    self.cleanupList = []
    self.daemon.connections[self.id]=self
    self.validating = 1
    self.log("OPEN")

  def __repr__(self):
    return '<swocket_server at %X %s module(%s) service(%s) vhost(%s)>'%(id(self),str(self),str(self.module),str(self.service),str(self.vhost))

  def __str__(self):
    return 'ip=%s count=%s'%(`self.ip`,`self.count`)

  def log(self,text):
    self.daemon.log("%d - %d - %s - %s - %s"%(self.count,self.id,self.ip,self.fullpath,text))

  def logerror(self,text):
    self.daemon.logerror("%d - %d - %s - %s - %s"%(self.count,self.id,self.ip,self.fullpath,text))

  def logdebug(self,text):
    self.daemon.logdebug("%d - %d - %s - %s - %s"%(self.count,self.id,self.ip,self.fullpath,text))

  def collect_incoming_data (self, data):
    self.buffer += data
    
  def found_terminator (self):
    """we just received a nice document, do stuff"""
    data = self.buffer
    self.buffer = ''
    if self.validating:
      try:
        doc = xmldom.parseString(data)
      except:
        self.error("invalid xml data")
        return
      for n in doc.childNodes:
        self.module.onXML(n)
      doc.unlink()
    else:
      # pass raw string to handler eventually
      pass
   
  def handle_error (self):
    """This should be more robust, but at least it prevents your
    program from getting screwed up and probably provides good debug info"""
    t,v,tb = sys.exc_info()
    try:
      raise v
    except socket.error,(num,name):
      self.error("socket.error: %s" % name)
    except:
      # print exception info to stderr, which should be filtered into debug log.
      print_exception(t,v,tb)

  def error (self, error=None):
    if error: self.logerror(error)
    self.destroy()
    
  def handle_close (self):
    self.log("CLOSE")
    self.module.onClose()
    for cleanup in self.cleanupList:
      cleanup(self)
    del(self.daemon.connections[self.id])
    self.close()
    
  def destroy (self):
    self.handle_close()

  def push (self,data,terminator=None):
    """send data to client"""
    try:
      if terminator==None: terminator=self.terminator
      asynchat.async_chat.push(self,data+terminator)
    except:
      self.error("push error")
      
class initModule:
  """this class intercepts the first transmission from the client"""
  def __init__ (self, parent):
    self.parent=parent
    
  def __repr__(self):
    return '<initModule at %X server(%s)>'%(id(self),str(self.parent))

  def onClose (self):
    """do nothing on close"""
    pass

  def onXML (self,doc):
    """check the connect string, authorize, and setup the handler module"""
    if not doc.nodeName == 'connect': return self.error("authorization xml must be a connect")
    if not doc.attributes.has_key('uri'): return self.error("authorization xml must have uri attribute")
    uri = doc.attributes['uri'].value
    uriList = string.split(uri, '/', 2)
    if len(uriList)<2: return self.error("uri must have at least 2 parts (%s)" % uri)
    elif len(uriList)==2: uriList.append('')
    (vhostName, path, extrapath) = uriList
    try:
      parent = self.parent
      vhost = parent.daemon.config.vhosts[vhostName]
      service = vhost.services[path]
      parent.vhost = vhost
      parent.vhostName = vhostName
      parent.path = path
      parent.fullpath = uri
      parent.service = service
      parent.extrapath = extrapath
      passInfo = {"self":parent,"doc":doc}
      authInfo = service.authmodule.authFunction(passInfo)
      passInfo["auth"]=authInfo
      parent.auth = authInfo
      parent.module = None
      parent.module = service.module.handlerClass(passInfo)
      parent.authInfo = authInfo
      parent.module.onConnect()
      self.parent = None
      
    except exceptions.KeyError:
      return self.error("%s/%s not in config" % (vhostName,path))

    except authorizeError,e:
      return self.error("%s/%s authorizeError: %s" % (vhostName,path,e))

    
  def error (self, error="error"):
    """bubble up any errors we get"""
    self.parent.error(error)


class configHost:
  """contains a host:port (bind)"""
  def __init__ (self, doc):
    for n in ('host','port','logmodule'):
      if not doc.attributes.has_key(n): raise configError("bind: missing %s attribute"%n)
    self.doc = doc
    self.host = self.doc.attributes['host'].value
    self.logmoduleName = self.doc.attributes['logmodule'].value
    try:    self.port = int(self.doc.attributes['port'].value)
    except: raise configError("bind: port value must be an integer")
    self.name = "%s:%s"%(self.host,self.port)
    self.vhosts = {}
    try:
      self.validate()
    except configError,e:
      print "[%s] %s"%(self.name,e) 

  def validate (self):
    """validate our config doc"""
    self.logmodule = string_import(self.logmoduleName)
    try:
      if not type(self.logmodule.logClass).__name__      == 'class'   : raise configError('%s.logClass must be a class' % self.moduleName)
      self.logclass = self.logmodule.logClass(self)
    except exceptions.NameError:
      raise configError("%s.handlerClass or %s.authFunction nonexistent" % (self.moduleName, self.authmoduleName))
    for x in self.doc.childNodes:
      if x.nodeType == x.ELEMENT_NODE:
        if x.nodeName == 'virtualhost':
          k = virtualHost(self,x)
          self.vhosts[k.name] = k
        else:
          print "(warning) %s is not a valid node in this context" % x.nodeName
  
  def log(self,text):
    self.logclass.log(text)

  def logerror(self,text):
    self.logclass.logerror(text)
    
  def logdebug(self,text):
    self.logclass.logdebug(text)

  def destroy (self):
    for x in self.vhosts.values():
      x.destroy()
    self.vhosts.clear()


class virtualHost:
  """contains a 'virtualHost'"""
  def __init__ (self, parent, doc):
    if not doc.attributes.has_key('name'): raise configError("all virtualhosts must have names")
    self.doc = doc
    self.name = self.doc.attributes['name'].value
    self.parent = parent
    self.services = {}
    self.state = {}
    self.validate()

  def validate (self):
    """validate our config doc"""
    try:
      for x in self.doc.childNodes:
        if x.nodeName == 'service':
          k = serviceContainer(self,x)
          self.services[k.path]=k
        elif not x.nodeName[0] == '#':
          print "warning: %s is not a valid node in virtualhost context" % x.nodeName
    except configError,e:
      raise configError("%s -> %s" % (self.name, e))

  def destroy (self):
    self.parent = None
    for x in self.services.values():
      x.destroy()
    self.services.clear()
    self.state.clear()

class serviceContainer:
  """contains a service description"""
  def __init__ (self, parent, n):
    for attrib in ('path','handlermodule','authmodule'):
      if not n.attributes.has_key(attrib): raise configError("service: missing %s attribute"%attrib)
    self.parent         = parent
    self.state          = {}
    self.path           = n.attributes['path'].value
    self.moduleName     = n.attributes['handlermodule'].value
    self.authmoduleName = n.attributes['authmodule'].value
    try:
      self.validate()
      self.authState      = self.authmodule.authInit(self,n)
      self.moduleState    = self.module.handlerInit(self,n)
    except configError,e:
      raise configError("%s - %s" % (self.path, e))
    
  def validate (self):
    """validate our config doc"""
    self.module     = string_import(self.moduleName)
    self.authmodule = string_import(self.authmoduleName)
    try:
      if not type(self.module.handlerClass)     == types.ClassType    : raise configError('%s.handlerClass must be a class'    % self.moduleName)
      if not type(self.authmodule.authFunction) == types.FunctionType : raise configError('%s.authFunction must be a function' % self.authmoduleName)
    except exceptions.NameError:
      raise configError("%s.handlerClass or %s.authFunction nonexistent" % (self.moduleName, self.authmoduleName))
    self.parent.parent.logerror("%s/%s (module=%s, authmodule=%s)" % (self.parent.name, self.path, self.moduleName, self.authmoduleName))

  def destroy (self):
    self.parent = None
    self.state.clear()