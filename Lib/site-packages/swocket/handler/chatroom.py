r"""This is an example of a simple one-room chatroom handler that
depends on the authorization handler passing a valid 'user' and
'userKey'.  'userKey' is anything that can uniquely identify the
user, could be as simple as the connection ID, short username, etc.
'user' is the display name for the client to use.  They can often
be the same value, but the client must keep track of other users
userKey if they are implementing private messages.

As an exercise, you should re-implement this module to allow users
to change their 'user' value (display name).  The functionality
would be similar to login/logout, using self.sendEveryone()"""

import string
from swocket import escape_markup,userNotFound,userError

def handlerInit(parent, n):
    """This handler requires no initialization routine,
    but must return a dict anyways"""
    return {}

class handlerClass:
    """the handlerClass is where everything happens, it depends on
    having 'user' and 'userKey' in passInfo['auth']"""
    def __init__ (self, passInfo):
        self.parent=passInfo["self"]
        self.auth=passInfo["auth"]
        self.name=self.auth['userKey']
        # 'inherited' from parent by __getattr__:
        # error (self,error="error") 
        # push (self,data,terminator=None):
        # service (class)
        # daemon (class)

    def __getattr__(self,name):
        return getattr(self.parent,name)
        
    def log (self,text):
        self.parent.log('%s - %s'%(self.name,text))

    def logerror(self,text):
        self.parent.logerror('%s - %s'%(self.name,text))

    def logdebug(self,text):
        self.parent.logdebug('%s - %s'%(self.name,text))
        
    def onConnect (self):
        """Upon successful connect, the client broadcasts a
        login message to all other connected users to notify
        them to update their user lists, and sends a full user
        list to the client (in no particular order)"""
        self.sendEveryone(self.loginXML())
        self.users()
        self.log('CONNECT')
        
    def onXML (self,doc):
        """When it receives data from the client, it passes control
        over to another method.  If the method raises an exception,
        it closes the connection and prints a message to the server
        console.  It otherwise ignores unknown messages, valid messages are:

        <broadcast text="%s" />
        - send a public message

        <msg userKey="%s" text="%s" />
        - send a private message to 'userKey'

        <logout />
        - logout gracefully

        <users />
        - return the user list... which isn't necessary, but we already
          have the method to do it, so we might as well implement it in
          the case of a really dumb client, like simpleclient"""
        try:
            if    doc.nodeName == "broadcast": self.broadcast(doc)
            elif  doc.nodeName == "msg": self.msg(doc)
            elif  doc.nodeName == "logout": self.logout()
            elif  doc.nodeName == "users": self.users()
        except:
            self.error("problem processing XML")
    
    def users (self):
        """Returns an xml document string of the current userlist"""
        xml=["<users>"]
        for (userKey,connID) in self.service.state["auth"].items():
          try: 
            xml.append('<user userKey="%s" user="%s"/>' % (userKey,self.connectionByID(connID).auth["user"]))
          except:
            pass
        xml.append("</users>")
        self.push(string.join(xml,''))
        
            
    def userError (self,error="something bad happened, its probably your fault"):
        """sends an <error value="%s" /> tag to the client, used if the client
        happens to send a tag with some invalid stuff in it, or they sent a message
        to a no longer existing 'userKey'"""
        self.logdebug('USERERROR - %s'%error)
        self.push('<error value="%s" />' % escape_markup(error))

    def broadcast (self,doc):
        """broadcasts a public message.  note: does NOT send to self"""
        try:
          if not doc.attributes.has_key('text'): raise userError("no text attribute")
          text = doc.attributes['text'].value
          self.sendEveryone(self.msgXML(text,1))
        except userError,e:
          self.userError("broadcast: %s" % e)
          
    def msg (self,doc):
        """sends a private message to 'userKey'"""
        try:
          if not doc.attributes.has_key('userKey'): raise userError("no userKey attribute")
          if not doc.attributes.has_key('text') : raise userError("no text attribute")
          userKey, text = doc.attributes['userKey'].value, doc.attributes['text'].value
          self.sendPerson(userKey,self.msgXML(text))
        except userError,e:
          self.userError("msg: %s" % e)
        except userNotFound, e:
          self.userNotFound("msg: %s not found" % e)

    def onClose (self):
        """when disconnecting, send everyone else a logout message"""
        self.sendEveryone(self.logoutXML())
        self.log('LOGOUT')
          
    def connectionByID (self, connID):
        """lookup a connection object by its connection id"""
        try:    return self.daemon.connections[connID].module
        except: raise userNotFound("connID=%s" % connID)
  
    def connectionByKey (self, userKey):
        """lookup a connection object by its 'userKey'"""
        try:    return self.connectionByID(self.service.state["auth"][userKey])
        except: raise userNotFound("userKey=%s" % userKey)
        
    def sendEveryone (self, xml):
        """sends the xml string to all users except self"""
        myKey = self.auth["userKey"]
        for (userKey,connID) in self.service.state["auth"].items():
            if not userKey==myKey:
              try: self.connectionByID(connID).push(xml)
              except: pass

    def sendPerson (self, userKey, xml):
        """sends the xml string to a particular user specified by 'userKey'"""
        self.connectionByKey(userKey).push(xml)
    
    def loginXML (self):
        """returns a login tag xml string with the current user's info in it"""
        return '<login user="%s" userKey="%s" />' % (self.auth["user"],self.auth["userKey"])

    def msgXML (self,msg, mode=0):
        """returns a msg tag xml string, with a mode flag (private=0, broadcast=1)"""
        return '<msg user="%s" userKey="%s" text="%s" mode="%d" />' % (self.auth["user"],self.auth["userKey"],escape_markup(msg),mode)
        
    def logoutXML (self):
        """returns a logout tag xml string with the current user's info"""
        return '<logout user="%s" userKey="%s" />' %  (self.auth["user"],self.auth["userKey"])
