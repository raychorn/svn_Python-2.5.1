r"""A abstract class for use when implementing aclient for the
swocket protocol.  It is derived from asynchat.async_chat, and
relies on xml.dom.minidom to handle the xml data packets from
the server.

The methods you should use are:
handle_close()  - kill the connection
push(data)      - push an entire data packet to the server
                  (termination is automatic)
pushXML(doc)    - push an xml.dom.minidom type document to
                  the server
"""

import asyncore,asynchat,socket
from swocket import xmldom

class swocket_xmlclient (asynchat.async_chat):
  """This is an abstract class, you must derive from this class and add
  these methods:
  onConnect()   - called when a connection has been established
  onClose()   - called when the connection has been lost
  onXML(doc)      - called when an xml document has arrived
            (doc is an xml.dom.minidom)

  It may be useful to override the error method.

  The initialization method accepts two parameters: host, and port.
  It will attempt to make a socket connection to the specified host,
  on the specified port.  Pretty obvious behavior."""
  def __init__ (self, host, port):
      asynchat.async_chat.__init__ (self)
      self.create_socket (socket.AF_INET, socket.SOCK_STREAM)
      self.terminator = '\0'
      self.connected = 0
      self.connect((host,port))
      self.buffer = ''

  def collect_incoming_data (self, data):
      self.buffer += data
  
  def found_terminator (self):
      data=self.buffer
      self.buffer = ''
      try:
        doc = xmldom.parseString(data)
      except:
        self.error("error reading xml from server?!")
        return
      for n in doc.childNodes:
          self.onXML(n)
      doc.unlink()

  def push (self, data):
      asynchat.async_chat.push(self,data+self.terminator)

  def pushXML (self, doc):
      """pushes an xml document to the client"""
      self.push(doc.toxml())

  def error(self,error="error"):
      """called whenever there are problems parsing xml from the server,
      shouldn't really happen often, if ever... unless your server is broken"""
      pass

  def handle_close (self):
      "call when you want to close the connection"
      self.connected = 0
      self.onClose()
      asyncore.socket_map.clear()
      raise asyncore.ExitNow

  def handle_connect (self):
      self.connected = 1
      self.onConnect()
  
  def log (self, *ignore):
      pass  