r"""authorize from a comma delimited plaintext file,
cache the file for speed, check its mtime and update
incase you feel like changing user/passwords during
runtime.. slick :)"""
import os,string
from swocket import authorizeError
from stat import *

def authInit (parent, doc):
    """do the initial setup and cache"""
    fname=findAttribute(doc.attributes,"passwordfile")
    delim=findAttribute(doc.attributes,"delimiter",',')
    rval={"delim":delim,"fname":fname,"mtime":0}
    checkFile(rval)
    return rval

def checkFile (pdict):
    """refresh our cache from the file if we need to"""
    fname=pdict["fname"]
    delim=pdict["delim"]
    mtime=os.stat(fname)[ST_MTIME]
    if  mtime>pdict["mtime"]:
        print "%s: reloading %s, file has changed" % (__name__,fname)
        dict = {}
        f=open(fname)
        for n in f.readlines():
            n=n.rstrip()
            if len(n)>1:
              (userKey,passw)=string.split(n,delim)
              dict[userKey]=passw
        f.close()
        pdict["mtime"]=mtime
        pdict["udict"]=dict


def authFunction (passInfo):
    """authorize the client"""
    parent = passInfo["self"]
    doc = passInfo["doc"]
    userKey = user = findAttribute(doc.attributes,"user")
    pw = findAttribute(doc.attributes,"password")
    pdict=parent.service.authState
    checkFile(pdict)
    if  not pdict["udict"].has_key(userKey):
        raise authorizeError("user %s not in password file" % userKey)
    if  not pdict["udict"][userKey]==pw:
        raise authorizeError("invalid password for user %s" % userKey)
    if not parent.service.state.has_key("auth"):
        parent.service.state["auth"]={}
    if parent.service.state["auth"].has_key(userKey):
        raise authorizeError("user %s is already connected" % user)
    parent.service.state["auth"][userKey] = parent.id
    parent.cleanupList.append(cleanup)
    return {"userKey":user,"user":user}

def findAttribute (attributes,key,default=None):
    """see ldap if you really can't figure this out"""
    try:
      val = attributes[key].value
    except:
      if not default==None: val=default
      else: raise authorizeError("attribute %s missing or invalid" % key)
    return val

def cleanup (self):
    """cleanup on user logout/disconnect"""
    del(self.service.state["auth"][self.auth["userKey"]])