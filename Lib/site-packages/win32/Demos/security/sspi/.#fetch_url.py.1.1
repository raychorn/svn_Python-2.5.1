"""
Fetches a URL from a web-server supporting NTLM authentication
eg, IIS.

If no arguments are specified, a default of http://localhost/localstart.asp
is used.  This script does follow simple 302 redirections, so pointing at the
root of an IIS server is should work.
"""

import sys
import urllib
import httplib
import urlparse
from base64 import encodestring, decodestring
import re
import win32security, sspicon

from sspi import ClientAuth

import optparse # sorry, this demo needs 2.3+

options = None # set to optparse options object

def open_url(host, url):
    h = httplib.HTTPConnection(host)
    h.set_debuglevel(9)
    h.putrequest('GET', url)
    h.endheaders()
    resp = h.getresponse()
    print "Initial response is", resp.status, resp.reason
    body = resp.read()
    if resp.status == 302: # object moved
        url = "/" + resp.msg["location"]
        resp.close()
        h.putrequest('GET', url)
        h.endheaders()
        resp = h.getresponse()
        print "After redirect response is", resp.status, resp.reason
    if options.show_headers:
        print "Initial response headers:"
        for name, val in resp.msg.items():
            print " %s: %s" % (name, val)
    if options.show_body:
        print body
    if resp.status == 401:
        # 401: Unauthorized - here is where the real work starts
        auth_info = None
        if options.user or options.domain or options.password:
            auth_info = options.user, options.domain, options.password
        for auth_hdr in resp.msg.getheaders("WWW-Authenticate"):
            # Eeek - this regex doesn't handle quoted quote chars!
            m = re.match('[ \t]*([^ \t]+)', auth_hdr)
            params = {}
            scheme = ""
            if m is not None:
                scheme = m.group(1).lower()
                rest = auth_hdr[m.span()[1]:]
                auth_value = rest
                while rest:
                    m = re.match('[ \t]*,?[ \t]*([^ \t]+)[ \t]*=[ \t]*"([^ \t]+)"', rest)
                    if m is None:
                        break
                    params[m.group(1)] = m.group(2)
                    rest = rest[m.span()[1]:]

            #sl = scheme.lower()
            if scheme.lower() in ["negotiate", "ntlm"]:
                # If I pass 'negotiate' to ClientAuth here, it appears to
                # perform the auth without the full NTLM dance??
                ca = ClientAuth("NTLM", auth_info=auth_info)
                break
            if scheme.lower() in ["digest"]:
                ca = ClientAuth("WDigest", auth_info=auth_info)
                break
            
        else:
            raise RuntimeError, "Don't handle any offered auth schemes"
        auth_scheme = ca.pkg_info['Name']


        credentials, \
        credentials_expiry=win32security.AcquireCredentialsHandle(
                                None, auth_scheme,
                                sspicon.SECPKG_CRED_OUTBOUND,
                                None, None)


        #data = decodestring(params["nonce"])
        data = "Digest" + auth_value
        context = None
        last = False
        while 1:

            context_in = context
            if context is None:
                context = win32security.CtxtHandleType()

            ISC_REQ_HTTP = 0x10000000
            scflags = ISC_REQ_HTTP | sspicon.ISC_RET_REPLAY_DETECT
                      # sspicon.ISC_REQ_SEQUENCE_DETECT|\
                      # sspicon.ISC_REQ_REPLAY_DETECT|ISC_REQ_HTTP #|sspicon.ISC_REQ_ALLOCATE_MEMORY
                      # docs say can't use sspicon.ISC_REQ_CONFIDENTIALITY with ISC_REQ_HTTP
                      # sspicon.ISC_REQ_INTEGRITY|??

            print "The data is", data

            sec_buffer_new=win32security.SecBufferDescType()
            # 0 SECBUFFER_TOKEN Empty 
            tokenbuf=win32security.SecBufferType(ca.pkg_info['MaxToken'],
                                                 sspicon.SECBUFFER_TOKEN)
            tokenbuf.Buffer = data
            sec_buffer_new.append(tokenbuf)

            # 1 SECBUFFER_PKG_PARAMS Method 
            val = "GET"
            tokenbuf=win32security.SecBufferType(len(val)+1,
                                                 sspicon.SECBUFFER_PKG_PARAMS)
            tokenbuf.Buffer = val
            sec_buffer_new.append(tokenbuf)

            # 2 SECBUFFER_PKG_PARAMS Hentity.
            # as if...
            import md5
            val = md5.new('').hexdigest()
            #val = ''
            tokenbuf=win32security.SecBufferType(len(val)+1,
                                                 sspicon.SECBUFFER_PKG_PARAMS)
            tokenbuf.Buffer = val
            sec_buffer_new.append(tokenbuf)

            # NOT filled in by sspi due to ISC_REQ_ALLOCATE_MEMORY flag
            sec_buffer_out=win32security.SecBufferDescType()
            tokenbuf=win32security.SecBufferType(ca.pkg_info['MaxToken'],
                                                 sspicon.SECBUFFER_TOKEN)
            sec_buffer_out.append(tokenbuf)

            err, attr, exp=win32security.InitializeSecurityContext(
                credentials,
                context_in,
                url,
                scflags,
                0,
                sec_buffer_new,
                context,
                sec_buffer_out)

            print "InitializeSecurityContext returned", err, attr, exp
#            print "Buffer has", len(sec_buffer_out)
#            print sec_buffer_out[0].Buffer

            data = sec_buffer_out[0].Buffer
            print "challenge response is", data
            if last:
                print "LAst one - breaking!"
                break
            h.putrequest('GET', url)
            h.putheader('Authorization', 'Digest ' + data)
            h.putheader('Content-Length', '0')
            h.endheaders()
            resp = h.getresponse()
            if options.show_headers:
                print "Token dance headers:"
                for name, val in resp.msg.items():
                    print " %s: %s" % (name, val)

            if err==0:
                print "Err - 0 - flagging as last"
                last = True
            else:
                if resp.status != 401:
                    print "Eeek - got response", resp.status
                    cl = resp.msg.get("content-length")
                    if cl:
                        got = resp.read(int(cl))
                        if options.show_body:
                            print repr(got)
                        else:
                            print "<specify --show-body to see error page>"
                    else:
                        print "no content!"

                assert resp.status == 401, resp.status

#            assert not resp.will_close, "NTLM is per-connection - must not close"
            #if scheme.lower() in ["ntlm", "negotiate"]:

            data = resp.msg.get("WWW-Authenticate", "")
        
            resp.read()
    print "Final response status is", resp.status, resp.reason
    if resp.status == 200:
        # Worked!
        # Check we can read it again without re-authenticating.
        if resp.will_close:
            print "EEEK - response will close, but NTLM is per connection - it must stay open"
        body = resp.read()
        if options.show_body:
            print "Final response body:"
            print body
        h.putrequest('GET', url)
        h.endheaders()
        resp = h.getresponse()
        print "Second fetch response is", resp.status, resp.reason
        if options.show_headers:
            print "Second response headers:"
            for name, val in resp.msg.items():
                print " %s: %s" % (name, val)
        
        resp.read(int(resp.msg.get("content-length", 0)))
    elif resp.status == 500:
        print "Error text"
        print resp.read()
    else:
        if options.show_body:
            cl = resp.msg.get("content-length")
            print resp.read(int(cl))

if __name__=='__main__':
    parser = optparse.OptionParser(description=__doc__)
    
    parser.add_option("", "--show-body", action="store_true",
                      help="print the body of each response as it is received")

    parser.add_option("", "--show-headers", action="store_true",
                      help="print the headers of each response as it is received")

    parser.add_option("", "--user", action="store",
                      help="The username to login with")

    parser.add_option("", "--password", action="store",
                      help="The password to login with")

    parser.add_option("", "--domain", action="store",
                      help="The domain to login to")

    options, args = parser.parse_args()
    if not args:
        print "Run with --help for usage details"
        args = ["http://localhost/localstart.asp"]
    for url in args:
        scheme, netloc, path, params, query, fragment = urlparse.urlparse(url)
        if (scheme != "http") or params or query or fragment:
            parser.error("Scheme must be http, URL must be simple")
    
        print "Opening '%s' from '%s'" % (path, netloc)
        r = open_url(netloc, path)
