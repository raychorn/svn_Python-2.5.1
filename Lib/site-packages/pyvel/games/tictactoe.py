r"""An example of a PyVel game handler where all
of the logic is server-side..
this pretty much makes it impossible to cheat,
and really easy to write clients."""

import string,exceptions
from swocket import escape_markup,userNotFound,userError
from random import randint
# a change in either of the first two parts of the version
# means that you have done something that will break client
# compatability, the third you can change for fun if you want
#
# this means you could make standalone versions of the game
# and expect normal behavior if you do it properly
__version__ = "0.1.0"
winningTuples = (
    (0,1,2),(3,4,5),(6,7,8), # horizontal
    (0,3,6),(1,4,7),(2,5,8), # veritcal
    (0,4,8),(2,4,6),         # diagonal
    )

class gameClass:
    """the tic-tac-toe game class"""

    def __init__(self,client,options):
        self.owner=client
        self.public=0
        self.open=1
        self.ready=0
        self.started=0
        self.alreadydead=0
        self.id=id(self)
        self.users=[]
        self.userKeys={}
        self.userScore={}
        self.inviteList=[]
        self.options=options
        self.version=options.version
        self.maxplayers = self.minplayers = 2
        self.avatars={"O":None,"X":None}
        self.title="%s v%s" % (__name__, __version__)
        self.join(client)

    def sendGameState(self):
        personTurn=self.users[self.turn]
        for client in self.users:
            client.push('<state board="%s" yourturn="%s" userKey="%s" user="%s" />' % (self.board, personTurn is client, personTurn.userKey, personTurn.user))
        if self.winner and self.winner!=' ':
            self.userScore[personTurn]+=1
            for client in self.users:
                client.push('<winner youwon="%s" userKey="%s" user="%s" />' % (personTurn is client, personTurn.userKey, personTurn.user))
                self.userlist(client)
            self.unreadyGame()
        elif self.winner:
            for client in self.users:
                client.push('<nowinner />')
                self.userlist(client)
            self.unreadyGame()

    def start(self):
        """begins the game"""
        self.useravatar={}
        for (key,val) in self.avatars.items():
            self.useravatar[val]=key
        self.started=1
        self.clearBoard()
        for n in self.users:
            self.userlist(n)

    def restart(self):
        """restarts the game"""
        self.clearBoard()

    def clearBoard(self):
        """Clears the gameplay board"""
        self.winner=None
        self.readyGame()
        self.board='         '
        # kinda silly since we know how many users we have but done this way for example
        self.turn=randint(0,len(self.users)-1)
        self.sendEveryone("<gamestart />")
        self.sendGameState()
        
    def checkWinner(self):
        """Check to see if the game has been won"""
        if ' ' not in self.board:
            return ' '
        for n in winningTuples:
            if self.board[n[0]]==self.board[n[1]]==self.board[n[2]]!=' ':
                return self.board[n[0]]

    def markspace(self,client,doc):
        if client is not self.users[self.turn]: raise userError("It's not your turn!")
        try:
            k=int(findAttribute(doc.attributes,'value'))
        except exceptions.ValueError:
            raise userError("Bad!  That's supposed to be an integer")
        if (k not in range(9)) or (self.board[k]!=' '): raise userError("You can't mark that!")
        # we have to do this because strings are IMMUTABLE in python..
        # we're merging the string before position k, the avatar character, and the string after position k
        self.board=self.board[:k]+self.useravatar[client]+self.board[k+1:]
        self.winner=self.checkWinner()
        if not self.winner:
            # cycle to the next user
            self.turn=(self.turn+1)%len(self.users)
        self.sendGameState()

    def join(self,client):
        """joins a user to the game group"""
        self.sendEveryone(self.loginXML(client)) # we don't need to exclude client, they're not listed yet
        self.addUser(client)
        self.userlist(client)
        if len(self.users)>=self.maxplayers: self.closeGame()
        if len(self.users)==self.minplayers: self.readyGame()
        else:                                self.unreadyGame()
        
    def leave(self,client):
        """removes a user from the game group"""
        if client==self.owner or self.started:
            self.killGame()
            return
        self.delUser(client)
        self.sendEveryone(self.logoutXML(client))      # we don't need to exclude client, they're not listed anymore
        if len(self.users)<=self.maxplayers:           # we already know the game isn't started yet..
            self.openGame()

    def unreadyGame(self):
        """Game is not ready to start"""
        self.ready=0
        self.sendEveryone("<gameunready />")
    
    def readyGame(self):
        """Game is ready to start"""
        self.ready=1
        self.sendEveryone("<gameready />")
    
    def openGame(self):
        """opens the game so other people can join
        possibly broadcasting its existence to the
        group of potential players"""
        self.open=1
        self.sendEveryone("<gameopen />")
        if self.public:
            # announce it someday
            pass

    def closeGame(self):
        """Closes the game, maxplayers is hit"""
        self.open=0
        self.sendEveryone("<gameclosed />")
        if self.public:
            # announce it someday
            pass

    def killGame(self):
        if not self.alreadydead:
            self.alreadydead=1
            self.owner.killGame()
            self.sendEveryone("<gameend />")
            for n in self.users:
                n.leaveGame()

    def addUser(self,client):
        self.users.append(client)
        self.userKeys[client.userKey]=client
        self.userScore[client]=0
        for (key,val) in self.avatars.items():
            if not val:
                self.avatars[key]=client
                return key

    def delUser (self,client):
        for (key,val) in self.avatars.items():
            if val==client:
                self.avatars[key]=None
        del(self.userKeys[client.userKey])
        del(self.userScore[client])
        self.users.remove(client)

    def userlist(self,client):
        rval=['<users>']
        for n in self.users:
            if not self.started:
                rval.append('<user userKey="%s" user="%s" />' % (n.userKey,n.user))
            else:
                rval.append('<user userKey="%s" user="%s" avatar="%s" score="%d" />' % (n.userKey,n.user,self.useravatar[n],self.userScore[n]))
        rval.append('</users>')
        client.push(string.join(rval,''))

    def broadcast (self,client,doc):
        """broadcasts a public message.  note: does NOT send to self"""
        if not doc.attributes.has_key('text'): raise userError("no text attribute")
        text = doc.attributes['text'].value
        self.sendEveryone(self.msgXML(client,text,1),client)

    def userError (self,client,error="something bad happened, its probably your fault"):
        """sends an <error value="%s" /> tag to the client, used if the client
        happens to send a tag with some invalid stuff in it, or they sent a message
        to a no longer existing 'userKey'"""
        client.push('<error value="%s" />' % escape_markup(str(error)))
        
    def sendEveryone (self,doc,exclude=None):
        for n in self.users:
            if n is not exclude and not n.markedfordeath: n.push(doc)

    def loginXML (self,client):
        """returns a login tag xml string with the current user's info in it"""
        return '<login user="%s" userKey="%s" />' % (client.user,client.userKey)

    def msgXML (self,client,msg, mode=0):
        """returns a msg tag xml string, with a mode flag (private=0, broadcast=1)"""
        return '<msg user="%s" userKey="%s" text="%s" mode="%d" />' % (client.user,client.userKey,escape_markup(msg),mode)
        
    def logoutXML (self,client):
        """returns a logout tag xml string with the current user's info"""
        return '<logout user="%s" userKey="%s" />' %  (client.user, client.userKey)

    def onXML (self,client,doc):
        """
        these are valid at all times and supposed to be captured by the handler above us:
            <msg userKey="%s" text="%s" />  (send a private message to 'userKey')
            <logout />                      (logout gracefully)
            <leavegame />                   (leave the current game)
        these are valid at all times:
            <broadcast text="%s" />         (send public message)
            <users />                       (lists users)
        these are valid when the game is open before its started:
            <invite userKey="%s" />         (invite userKey to game)
            <inviteusers />                 (list users that you can potentially invite)
        these are valid for the game owner only:
            <gamestart />                   (only when the game is ready, or ready to restart)
        these are valid for the user when its their turn:
            <markspace value="%S" />        (mark space, value is the index number from 0-8)
        """
        try:
            if    doc.nodeName == "broadcast": self.broadcast(client,doc)
            elif  doc.nodeName == "users": self.userlist(client)
            elif  self.started:
                if not self.ready:
                    if client is self.owner and doc.nodeName == "gamestart": self.restart()
                else:
                    if doc.nodeName == "markspace": self.markspace(client,doc)
            else:
                if self.ready and (client is self.owner) and (doc.nodeName=="gamestart"): self.start()
                elif self.open:
                    if doc.nodeName == "invite": self.invite(client,doc)
                    if doc.nodeName == "inviteusers": client.inviteusers()
        except userError,e:
            self.userError(client,e)

    def invite(self,client,doc):
        inviteMsg='<invite userKey="%s" user="%s" gameid="%s" version="%s" />' % (client.userKey,escape_markup(client.user), self.id, escape_markup(self.options.version))
        try:
            target=client.connectionByKey(findAttribute(doc.attributes,'userKey'))
            self.inviteList.append(target.userKey)
            target.push(inviteMsg)
        except userNotFound:
            raise userError("invite: user not found")
        except userError,e:
            raise userError("invite: %s"%e)

def gameInit(parent,node):
    """initialize the game service"""
    # no init necessary
    pass

def findAttribute (attributes,key,default=None):
    """helper function to see if an xml attribute list has a certain key.
    accepts a default incase it doesn't exist, otherwise it raises an
    configError"""
    try:
      val = attributes[key].value
    except:
      if not default==None: val=default
      else: raise userError("attribute %s missing or invalid" % key)
    return val