r"""Core functionality of pyvel"""

import string,exceptions
from swocket import xmldom,escape_markup,string_import,userNotFound,userError,configError

class gameOptions:
    """This class sets up all the games for a particular PyVel instance"""
    def __init__(self,service,path,node):
        self.service=service
        self.path=path
        self.moduleName=findAttribute(node.attributes,'module')
        self.validate(node)
        # used to check client compatability, only use major and minor parts of the version.. i.e. 1.2.3 -> 1.2
        self.version="%s %s"%(self.moduleName, string.join(string.split(self.module.__version__,'.')[:2],'.'))
        try: self.state = self.module.gameInit(self,node)
        except configError,e: raise configError("%s -> %s" % (self.path,e))
        
    def validate(self,node):
        """Validate config information for a particular game node"""
        try:
            self.module = string_import(self.moduleName)
            try:
                if not type(self.module.gameClass).__name__ == 'class': raise configError('%s.gameClass must be a class' % self.moduleName)
                if not type(self.module.gameInit).__name__ == 'function': raise configError('%s.gameInit must be a function' % self.moduleName)
            except exceptions.AttributeError:
                raise configError("%s.gameClass or %s.gameInit nonexistent" % (self.moduleName, self.moduleName))
        except configError,e:
            raise configError("%s -> %s" % (self.path,e))

    def spawnGame(self,owner):
        pass
    
def handlerInit(service,node):
    """pyvel initialization.. This is where we load
    our modules and setup the state objects"""
    if not service.state.has_key("groups"):
        service.state["groups"]={'/':{}}
    if not service.state.has_key("games"):
        service.state["games"]={}
    rdict={}
    for n in node.childNodes:
        if n.nodeName=='game':
            gamepath = '/'+findAttribute(n.attributes,'path')
            service.state["groups"][gamepath]={}
            rdict[gamepath]=gameOptions(service,gamepath,n)
        elif not n.nodeName[0] == '#':
            raise configError("%s is not a valid pyvel config node" % n.nodeName)
    return rdict

class handlerClass:
    """pyvel handler"""
    def __init__ (self, passInfo):
        self.parent=passInfo["self"]
        self.auth=passInfo["auth"]
        self.userKey = self.auth["userKey"]
        self.user = self.auth["user"]
        self.groups = self.parent.service.state["groups"]
        self.games = self.parent.service.state["games"]
        self.gameOptions = self.parent.service.moduleState
        self.game = None
        self.myGroup = None
        self.markedfordeath=0

    def __getattr__ (self,name):
        return getattr(self.parent,name)
        
    def onConnect (self):
        """Join the proper game group, send user list,
        notify everyone local about it"""
        self.joinGroup(self.parent.extrapath)

    def onClose (self):
        """send logout message, close"""
        self.markedfordeath=1
        if self.game:
            self.game.leave(self)
        elif not self.myGroup==None:
            group=self.groups[self.myGroup]
            del(group[self.userKey])
            self.sendEveryone(self.logoutXML())

    def onXML (self,doc):
        """return the same stuff we received"""
        try:
            if  doc.nodeName == "msg": self.msg(doc)
            elif  doc.nodeName == "logout": self.error("logout")
            elif not self.game:
                if    doc.nodeName == "broadcast": self.broadcast(doc)
                elif  doc.nodeName == "users": self.users()
                elif  doc.nodeName == "joingroup": self.joinGroup(doc)
                elif  doc.nodeName == "startgame": self.startGame(doc)
                elif  doc.nodeName == "joingame": self.joinGame(doc)
                elif  doc.nodeName == "grouplist": self.groupList(doc)
            elif doc.nodeName == "leavegame": self.leaveGame()
            else:
                self.game.onXML(self,doc)
        except userError,e:
            self.userError(e)

    def users (self):
        rval=['<users>']
        for (userKey,connID) in self.groups[self.myGroup].items():
            user=self.connectionByID(connID)
            rval.append('<user userKey="%s" user="%s" />'%(user.userKey,user.user))
        rval.append('</users>')
        self.push(string.join(rval,''))

    def inviteusers(self):
        rval=['<inviteusers>']
        for (userKey,connID) in self.groups[self.myGroup].items():
            user=self.connectionByID(connID)
            rval.append('<user userKey="%s" user="%s" />'%(user.userKey,user.user))
        rval.append('</inviteusers>')
        self.push(string.join(rval,''))

    def joinGroup (self,doc):
        """join the group given by path if possible"""
        if type(doc).__name__ in ("string","unicode"):
            path=doc
        else: path=findAttribute(doc.attributes,'path','')
        if not len(path)>0: path="/"
        if not path[0]=="/":
            path="/"+path
        try:
            if not self.groups.has_key(path):
                raise userError("Invalid group")
            self.leaveGroup()
            self.groups[path][self.userKey]=self.parent.id
            self.myGroup=path
            self.push('<joingroup path="%s" />'%escape_markup(self.myGroup))
            self.sendEveryone(self.loginXML())
            self.users()
        except userError,e:
            raise userError("joinGroup: %s"%e)

    def leaveGroup(self):
        """leave the current group if we need to"""
        if not self.myGroup==None and self.groups[self.myGroup].has_key(self.userKey):
            del(self.groups[self.myGroup][self.userKey])
            self.sendEveryone(self.logoutXML())

    def joinGame(self,doc):
        """join the game at gameid"""
        try:
            gameid=int(findAttribute(doc.attributes,'gameid'))
            version=findAttribute(doc.attributes,'version')
        except configError,e:
            raise userError("joingame: %s"%e)
        except exceptions.ValueError:
            raise userError("Invalid game")
        if not self.games.has_key(gameid):
            raise userError("Invalid game")
        if not self.games[gameid].open:
            raise userError("Game not open")
        if not self.games[gameid].public and self.userKey not in self.games[gameid].inviteList:
            raise userError("You're not invited to participate")
        if version != self.games[gameid].version:
            raise userError("You are using an incompatible version (you:%s,server:%s)" % (version,self.games[gameid].version))
        self.game=self.games[gameid]
        self.game.join(self)
        self.leaveGroup()

    def startGame(self,doc):
        try:
            gamepath=findAttribute(doc.attributes,'gamepath',self.myGroup)
            version=findAttribute(doc.attributes,'version')
            public=int(findAttribute(doc.attributes,'public',0))
        except configError,e:
            raise userError("startGame: %s"%e)
        except exceptions.ValueError:
            raise userError("startGame: public must be 0 or 1!")
        options=self.gameOptions[gamepath]
        if version!=options.version:
            raise userError("You are using an incompatible version (you:%s,server:%s)" % (version,options.version))
        self.game=options.module.gameClass(self,options)
        self.game.public=public
        self.games[self.game.id]=self.game
        if public:
            # announce it someday
            pass
        self.leaveGroup()

    def killGame(self):
        del(self.games[self.game.id])
    
    def leaveGame(self):
        """leave the current game"""
        if not self.game:
            raise userError("Not playing a game")
        self.game.leave(self)
        self.game=None
        if not self.markedfordeath:
            self.joinGroup(self.myGroup)

    def connectionByID (self, connID):
        """lookup a connection object by its connection id"""
        try:    return self.parent.daemon.connections[connID].module
        except: raise userNotFound("connID=%s" % connID)
  
    def connectionByKey (self, userKey):
        """lookup a connection object by its 'userKey'"""
        try:    return self.connectionByID(self.parent.service.state["auth"][userKey])
        except: raise userNotFound("userKey=%s" % userKey)

    def userError (self,error="something bad happened, its probably your fault"):
        """sends an <error value="%s" /> tag to the client, used if the client
        happens to send a tag with some invalid stuff in it, or they sent a message
        to a no longer existing 'userKey'"""
        self.push('<error value="%s" />' % escape_markup(str(error)))

    def groupList (self,doc=None):
        """Return the list of groups in the current context"""
        # note that we use a list instead of adding to the string
        # because strings are IMMUTABLE in python, unlike perl.
        # Adding to a string would cause a new string to be created
        # and the old one destroyed, which is inefficient.
        myRoom=self.myGroup
        rval=['<groups base="%s">' % myRoom]
        myRoom=self.myGroup
        myLen=len(myRoom)
        for room in self.groups.keys():
            if len(room)>myLen and room[:myLen]==myRoom:
                (group,)=string.split(room[myLen:],'/',1)[:1]
                if self.gameOptions.has_key(room):
                    ver=self.gameOptions[room].version
                    rval.append('<group path="%s" name="%s" version="%s" />' % (room,group,ver))
                else:
                    rval.append('<group path="%s" name="%s" />' % (room,group))
        rval.append('</groups>')
        self.push(string.join(rval,''))

    def sendEveryone (self, xml):
        """sends the xml string to all users in group except self"""
        myKey = self.auth["userKey"]
        for (userKey,connID) in self.groups[self.myGroup].items():
            if not userKey==myKey:
              try: self.connectionByID(connID).push(xml)
              except: pass

    def broadcast (self,doc):
        """broadcasts a public message.  note: does NOT send to self"""
        try:
          if not doc.attributes.has_key('text'): raise userError("no text attribute")
          text = doc.attributes['text'].value
          self.sendEveryone(self.msgXML(text,1))
        except userError,e:
          raise userError("broadcast: %s" % e)
          
    def msg (self,doc):
        """sends a private message to 'userKey'"""
        try:
          if not doc.attributes.has_key('userKey'): raise userError("no userKey attribute")
          if not doc.attributes.has_key('text') : raise userError("no text attribute")
          userKey, text = doc.attributes['userKey'].value, doc.attributes['text'].value
          self.sendPerson(userKey,self.msgXML(text))
        except userError,e:
          raise userError("msg: %s" % e)
        except userNotFound, e:
          raise userError("msg: %s not found" % e)

    def msgXML (self,msg, mode=0):
        """returns a msg tag xml string, with a mode flag (private=0, broadcast=1)"""
        return '<msg user="%s" userKey="%s" text="%s" mode="%d" />' % (self.auth["user"],self.auth["userKey"],escape_markup(msg),mode) 

    def sendPerson (self, userKey, xml):
        """sends the xml string to a particular user specified by 'userKey'"""
        self.connectionByKey(userKey).push(xml)

    def loginXML (self):
        """returns a login tag xml string with the current user's info in it"""
        return '<login user="%s" userKey="%s" />' % (self.auth["user"],self.auth["userKey"])

    def logoutXML (self):
        """returns a logout tag xml string with the current user's info"""
        return '<logout user="%s" userKey="%s" />' %  (self.auth["user"],self.auth["userKey"])    
              
def findAttribute (attributes,key,default=None):
    """helper function to see if an xml attribute list has a certain key.
    accepts a default incase it doesn't exist, otherwise it raises an
    configError"""
    try:
      val = attributes[key].value
    except:
      if not default==None: val=default
      else: raise configError("attribute %s missing or invalid" % key)
    return val